% !TEX encoding = UTF-8 Unicode
\documentclass[svgnames]{report}
\usepackage[utf8]{inputenc} 
\usepackage{polski}       
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{bbm}            % sudo apt-get install texlive-fonts-recommended texlive-fonts-extra
\usepackage{amsthm}
\usepackage{algorithmic}	% sudo apt-get install texlive-science
\usepackage{listings}             % Include the listings-package
\usepackage{framed}
\usepackage{enumerate}
\usepackage{hyperref}


\makeatletter
 \renewcommand\@seccntformat[1]{\csname  the#1\endcsname.\quad}
  

\lstset{language=C}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{parts/1.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lista 2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lista 3}

\section{} %1
Zadanie to polega na skonstruowaniu szybkiego algorytmu obliczania największego wspólnego dzielnika dwóch dodatnich liczb całkowitych $a$ i $b$. Przed podaniem algorytmu musimy udowodnić podane właściwości:

\begin{equation*}
gcd(a,b) =
 \begin{cases}
 2 \cdot gcd( \frac{a}{2}, \frac{b}{2}) & \text{a,b są parzyste;} \\
 gcd(a,\frac{b}{2}) & \text{a jest nieparzyste, b jest parzyste;} \\
 gcd(\frac{a-b}{2},b) & \text{a,b są nieparzyste.}
 \end{cases}
 \end{equation*}

\subsection{a)}
Jeżeli $a$ i $b$ są parzyste, $2$ na pewno jest ich wspólnym dizelnikiem. Jeżeli $a$ jest nieparzyste i $b$ jest parzyste, wiemy że $b$ dzieli się przez 2, a $a$ nie. Więc $gcd(a,b)$ pozostaje takie same dla $a$ i $b/2$. Ostatnia własność wynika z faktu, że dla nieparzystych $a$ i $b$, $(a-b)$ będzie parzyste.Ponieważ $gcd(a-b,b) = gcd(a,b)$ oraz $(a-b)$ jest teraz parzyste, możemy zastosować drugą własność.

\subsection{b) algorytm rekurencyjny}
\begin{lstlisting}
procedure gcd(a, b)
Input: Two n-bit integers a,b
Output: GCD of a and b
if a = b:
	return a
else if (a is even and b is even):
	return 2*gcd(a/2, b/2)
else if (a is odd and b is even):
	return gcd(a, b/2)
else if (a is odd and b is odd and a > b):
	return gcd((a-b)/2, b)
else if (a is odd and b is odd and a < b):
	return gcd(a,(b-a)/2)
\end{lstlisting}
\subsection{c) złożoność}
Założmy, że $a$ i $b$ są n-bitowymi liczbami. Rozmiar $a$ i $b$ wynosi $2n$ bitów. Wszystkie z czterech ifów, oprócz przypadku gdzie $a$ jest nieparzyste i $b$ jest parzyste, zmniejsza rozmiar $a$ i $b$ do $2n - 2$ bitów, gdzie wcześniej wymieniony przypadek zmniejsza ilość bitów do $2n-1$. Każda z operacji wykonuje się w czasie stałym ponieważ dzielimy lub mnożymy przez 2. Dla dwóch przypadków z odejmowaniem, mamy odejmowanie dwóch n-bitowych liczb (złożoność wynosi $c\cdot n$ gdzie n jest wielkością operandu). Zatem najgorszy przypadek czwartego ifa algorytmu przedstawimy jako:

\begin{equation*}
\begin{split}
T(2n) & = T(n-1) + cn \\
T(2n -1) & = T(2n - 2) + cn \\
T(2n - 2) & = T(2n - 3) + c(n-1)  \text{   oba operandy mają długość $n-1$} \\
T(2n - 3) & = T(2n - 4) + c(n-1) \\
... &  \\
T(2) &=  T(1) + c
\end{split}
\end{equation*}

Podstawieniami możemy zapisać $T(2n)$ jako:
$$ T(2n) = 2c\cdot \sum_{i=1}^n i $$
co daje nam $O(n^2)$ co w porównaniu do $O(n^3)$ czasu działania algorytmu euklidesa jest szybsze.
\section{} %2
\href{./solutions/lista_3_zadanie_2.pdf}{PDF}

\section{} %3
\section{} %4
\section{} %5
\subsection{a)}
W wektorze pamiętamy pierwszą kolumnę oraz pierwszy wiersz bez pierwszego wyrazu. Wektor ten ma rozmiar $2n - 1$, więc dodawanie dwóch takich wektorów mamy w $O(n)$.
\subsection{b)}
Macierz Toeplitza ma następującą postać blokową:
$$ T = \left[ \begin{matrix}
					A & B \\
					C & A
				\end{matrix} \right]$$

Zadanie polega na pomnożeniu macierzy T przez wektor blokowy $ T = \left[ \begin{matrix}x \\ y\end{matrix} \right] $ w czasie mniejszym niż $n^2$. Korzystając z dwóch (wzajemnie dualnych) obserwacji:

$$Ax = A(x + y - y) = A(x+y) - Ay$$

$$Ay = A(x + y - x) = A(x+y) - Ax$$


mamy:


\begin{equation*}
\begin{split}
T = \left[ \begin{matrix}A & B\\ C & A\end{matrix} \right] \cdot \left[ \begin{matrix} x \\ y\end{matrix} \right] = \left[ \begin{matrix} Ax + By\\ Cx + Ay\end{matrix} \right] = \\
= \left[ \begin{matrix}A(x+y)-Ay + By\\ Cx + Ay\end{matrix} \right] = \left[ \begin{matrix}A(x+y)+(B - A)y\\ Cx + Ay\end{matrix} \right] = \\
= \left[ \begin{matrix}A(x+y)+(B - A)y\\ Cx + A(x+y) - Ax \end{matrix} \right] =  \left[ \begin{matrix}A(x+y)+(B - A)y\\ A(x+y) + (C-A)x\end{matrix} \right]
\end{split}
\end{equation*}

I zauważamy, że złożoność czasowa to $T(n) = 3 T(n/2) + O(n)$ gdzie $O(n)$ zamyka sumę liniowych czasów wszystkich dodawań.

Rozwiązując typowe równanie rekurencyjne mamy $T(n) = O(n^{log_2 3}) < O(n^2)$.


\section{} %6
\section{} %7


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lista 4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lista 5}
\end{document}